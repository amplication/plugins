// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`Testing afterCreateApp hook should create all the auth modules 1`] = `
[
  {
    "code": "import { Injectable } from "@nestjs/common";
import { JwtStrategyBase } from "./base/jwt.strategy.base";
import { ConfigService } from "@nestjs/config";
import { Auth0User } from "./base/User";
import { IAuthStrategy } from "../IAuthStrategy";
import { UserInfo } from "../UserInfo";
import { UserService } from "src/user/user.service";

@Injectable()
export class JwtStrategy extends JwtStrategyBase implements IAuthStrategy {
  constructor(
    protected readonly configService: ConfigService,
    protected readonly userService: UserService
  ) {
    super(configService, userService);
  }

  async validate(payload: { user: Auth0User }): Promise<UserInfo> {
    const validatedUser = await this.validateBase(payload);
    // If the entity is valid, return it
    if (validatedUser) {
      return validatedUser;
    }

    // Otherwise, make a new entity and return it
    const userFields = payload.user;
    const { name, email } = userFields;

    const newUser = await this.userService.create({
      data: {
        name,
        email,
        ...userFields,
        // TODO: Add the rest of the fields here according to your authEntity schema
      },
    });

    return { ...newUser, roles: newUser?.roles as string[] };
  }
}
",
    "path": "undefined/jwt/jwt.strategy.ts",
  },
  {
    "code": "import { ConfigService } from "@nestjs/config";
import { PassportStrategy } from "@nestjs/passport";
import { passportJwtSecret } from "jwks-rsa";
import { ExtractJwt, Strategy } from "passport-jwt";
import { Auth0User } from "./User";
import { UserInfo } from "../../UserInfo";
import { UserService } from "src/user/user.service";

export class JwtStrategyBase extends PassportStrategy(Strategy) {
  constructor(
    protected readonly configService: ConfigService,
    protected readonly userService: UserService
  ) {
    super({
      jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(), // Extract JWT from the Authorization header
      audience: configService.get("AUTH0_AUDIENCE"), // The resource server where the JWT is processed
      issuer: \`\${configService.get("AUTH0_ISSUER_URL")}\`, // The issuing Auth0 server
      algorithms: ["RS256"], // Asymmetric signing algorithm

      secretOrKeyProvider: passportJwtSecret({
        cache: true,
        rateLimit: true,
        jwksRequestsPerMinute: 5,
        jwksUri: \`\${configService.get(
          "AUTH0_ISSUER_URL"
        )}.well-known/jwks.json\`,
      }),
    });
  }

  // Validate the received JWT and construct the user object out of the decoded token.
  async validateBase(payload: {
    user: Auth0User;
  }): Promise<UserInfo | null> {
    const { email, name } = payload.user;
    const user = await this.userService.findOne({
      where: {
        name_email: { email, name },
      },
    });

    return user ? { ...user, roles: user?.roles as string[] } : null;
  }
}
",
    "path": "undefined/jwt/base/jwt.strategy.base.ts",
  },
  {
    "code": "import { Module, forwardRef } from "@nestjs/common";
import { PassportModule } from "@nestjs/passport";
import { JwtStrategy } from "./jwt/jwt.strategy";
import { UserModule } from "../user/user.module";

@Module({
  imports: [
    forwardRef(() => UserModule),
    PassportModule.register({ defaultStrategy: "jwt" }),
  ],
  providers: [JwtStrategy],
  controllers: [],
  exports: [PassportModule],
})
export class AuthModule {}
",
    "path": "undefined/auth.module.ts",
  },
  {
    "code": "import * as common from "@nestjs/common";
import { Query, Resolver } from "@nestjs/graphql";
import * as gqlACGuard from "../auth/gqlAC.guard";
import { GqlDefaultAuthGuard } from "./gqlDefaultAuth.guard";
import { UserData } from "./userData.decorator";
import { UserInfo } from "./UserInfo";

@Resolver(UserInfo)
export class AuthResolver {
  @Query(() => UserInfo)
  @common.UseGuards(GqlDefaultAuthGuard, gqlACGuard.GqlACGuard)
  async userInfo(
    @UserData() entityInfo: UserInfo
  ): Promise<UserInfo> {
    return entityInfo;
  }
}
",
    "path": "undefined/auth.resolver.ts",
  },
  {
    "code": "import { Observable } from "rxjs";
import { ExecutionContext, Injectable } from "@nestjs/common";
import { Reflector } from "@nestjs/core";
import { IS_PUBLIC_KEY } from "../decorators/public.decorator";
import { JwtAuthGuard } from "./jwt/jwtAuth.guard";

@Injectable()
export class DefaultAuthGuard extends JwtAuthGuard {
  constructor(private readonly reflector: Reflector) {
    super();
  }

  canActivate(
    context: ExecutionContext
  ): boolean | Promise<boolean> | Observable<any> {
    const isPublic = this.reflector.get<boolean>(
      IS_PUBLIC_KEY,
      context.getHandler()
    );

    if (isPublic) {
      return true;
    }

    return super.canActivate(context);
  }
}
",
    "path": "auth/defaultAuth.guard.ts",
  },
  {
    "code": "export interface Auth0User {
  nickname: string;
  username: string;
  name: string;
  email: string;
  picture: string;
  given_name: string;
  family_name: string;
}
",
    "path": "auth/jwt/base/User.ts",
  },
  {
    "code": "import { ExecutionContext } from "@nestjs/common";
import { AuthGuard } from "@nestjs/passport";
import { Observable } from "rxjs";

export class JwtAuthGuard extends AuthGuard("jwt") {
  canActivate(
    context: ExecutionContext
  ): boolean | Promise<boolean> | Observable<boolean> {
    const promiseOrBoolean = super.canActivate(context);
    if (promiseOrBoolean instanceof Promise) {
      return promiseOrBoolean.then((result) => {
        return result;
      });
    } else {
      return promiseOrBoolean;
    }
  }
}
",
    "path": "auth/jwt/jwtAuth.guard.ts",
  },
]
`;
